;*********************************;;         PRG2OBJ64;      PRG2OBJ.C64 V072882;     CONVERT PROGRAM FILE;  TO ASSEMBLER64 OBJECT FILE;; (C) 1982 BY COMMODORE MACHINES;;  WRITTEN BY DENTON MARLOWE;*********************************; MAIN BODY OF CODE;*********************************; ZEROPAGE USAGE EQUATES;*********************************STATUS=$90         ;STATUS BYTEZEROPG=$FB         ;ZERO PAGE POINTERZEROUR=$FD         ;ZERO PAGE POINTER;*********************************; KERNAL JMUP TABLE EQUATES;*********************************STOP  =$FFE1       ;CHECK FOR STOPSETLFS=$FFBA       ;SET LOGICAL FILESETNAM=$FFBD       ;SET FILENAMEOPEN  =$FFC0       ;OPEN FILECLOSE =$FFC3       ;CLOSE LOGICAL FILECHKIN =$FFC6       ;OPEN INPUT CHANNELCHKOUT=$FFC9       ;OPEN OUTPUT CHANNELCLRCHN=$FFCC       ;RESET I/O CHANNELSCHRIN =$FFCF       ;GET KEYBOARD INPUTCHROUT=$FFD2       ;OUTPUT CHARACTERREADST=$FFB7       ;READ I/O STATUS;*********************************;; LOADER64 ENTRY POINT;;*********************************LOADER =*       JSR CLRCHN    ;RSET I/O       LDA #$00      ;ZERO BYTE       STA RECORD    ;RECORD COUNT       STA RECORD+1  ;       STA STADD     ;START ADDRESS       STA STATUS    ;I/O STATUS       STA SAFG      ;CLEAR START ADDRESS FLAG       STA SCROPT    ;SCREEN OUTPUT OPTION       STA RECHI       STA RECLO       STA CHKSUM       STA CHKSUM+1;*********************************; INIT DISK;*********************************INITD  LDA #$02       LDY #>INIT       LDX #<INIT       JSR SETNAM       LDA #$0F       LDX #$08       LDY #$0F       JSR SETLFS       JSR OPEN       LDA #$0F       JSR CLOSE       JSR DISERR       BCC INITOK       JMP QUITER;*********************************; OPEN FILE TO SCREEN;*********************************INITOK =*       LDA #$03      ;FILE #3       LDX #$03      ;DEVICE #3       LDY #$00      ;SECOND ADDRESS       JSR SETLFS    ;SET FILE;       LDA #$00      ;GET LENGTH       LDX #$00      ;LOW FILENAME       LDY #$00      ;HIGH FILENAME       JSR SETNAM    ;SET FILENAME       JSR OPEN      ;OPEN FILE        LDX #$03      ;FILE #3       JSR CHKOUT    ;SET TO OUTPUT;*********************************; PRINT TITLE;*********************************       LDX #MSG7-MSG1 ;OFFSET FOR TITLE       JSR PRINT      ;PRINT TITLE;*********************************; PROMPT FOR PRG FILENAME;*********************************       LDX #MSG9-MSG1 ;OFFSET FOR MSG       JSR PRINT      ;PRG NAME:;*********************************; READ IN PRG FILE NAME;*********************************       JSR INSTNP;*********************************; APPEND ,P,R;*********************************PFILE2 LDX #$00PFILE3 LDA PROGM,X       STA PUF,Y       INY       INX       CPX #$04       BNE PFILE3       STY SAVP    ; LENGTH OF FILE NAME;*********************************; OUTPUT CARRAIGE RETURN;*********************************       LDA #$0D    ;ASCII CR       JSR CHROUT  ;PRINT IT;*********************************; PROMPT FOR OBJ FILENAME;*********************************       LDX #MSG8-MSG1 ;OFFSET FOR MSG       JSR PRINT      ;PRG NAME:;*********************************; READ IN INTERFACE FILE NAME;*********************************       JSR INSTNO;*********************************; APPEND ,S,W;*********************************PFILE0 LDX #$00PFILE1 LDA OBJM,X       STA OUF,Y       INY       INX       CPX #$04       BNE PFILE1       STY SAVO ; LENGTH OF FILE NAME;*********************************; SCREEN OUTPUT OPTION (VERBOSE);*********************************       LDA #<MSS1  ;LOW BYTE MESSAGE       LDY #>MSS1  ;HIGH BYTE MESSAGE       JSR STRPNT  ;OUTPUT MESSAGE       JSR CRNO    ;GET KEY PRESS       BCS SOP1    ;C=0 YES C=1 NO       LDA #$00       STA SCROPT       BEQ OPENPFSOP1   LDA #$01       STA SCROPT   ;*********************************; OPEN PROGRAM FILE;*********************************OPENPF =*       LDA #$08    ;FILE #7       LDX #$08    ;DEVICE #8       LDY #$08    ;SECOND ADDRESS       JSR SETLFS  ;SET FILE;       LDA SAVP    ;GET LENGTH       LDX #<PUF   ;LOW FILENAME       LDY #>PUF   ;HIGH FILENAME       JSR SETNAM  ;SET FILENAME       JSR OPEN    ;OPEN FILE;       JSR DISERR       BCC PRGOK       JMP QUITER;*********************************; OPEN OBJECT FILE;*********************************PRGOK =*       LDA #$07    ;FILE #7       LDX #$08    ;DEVICE #8       LDY #$07    ;SECOND ADDRESS       JSR SETLFS  ;SET FILE;       LDA SAVO    ;GET LENGTH       LDX #<OUF   ;LOW FILENAME       LDY #>OUF   ;HIGH FILENAME       JSR SETNAM  ;SET FILENAME;       JSR OPEN    ;OPEN FILE;       JSR DISERR       BCC OBJOK       JMP QUITER;*********************************; SET INPUT TO PROGRAM FILE;*********************************OBJOK =*       LDX #$08    ;FILE #8       JSR CHKIN   ;INPUT FILE;*********************************; NEW LINE;*********************************       LDA #$0D    ;CR       JSR CHROUT  ;OUTPUT TO SCREEN;*********************************; READ IN START ADDRESS FROM FILE;*********************************       LDA #$01       STA STADD  ;LOAD ADDRESS FLAG       JSR CHRIN  ;LOW BYTE START ADDRESS       STA ADDLO       STA RECLO  ;RECORD ADDRESS LOW BYTE       JSR CHRIN  ;HIGH BYTE START ADDRESS       STA ADDHI       STA RECHI  ;RECORD ADDRESS HIGH BYTE;*********************************; ZERO RECORD COUNTER;*********************************       LDA #$00       STA RECCNT       STA RECCNT+1;*********************************; BUILD RECORDS;*********************************CLOOP =*;*********************************; RECORD STARTING CHARACTER;*********************************       LDA SCROPT       BEQ SSEMI1       LDA #$';'       JSR CHROUT;*********************************; INCREMENT RECORD COUNTER;*********************************SSEMI1 =*       CLC       LDA #$01       ADC RECCNT       STA RECCNT       LDA #$00       ADC RECCNT+1       STA RECCNT+1;*********************************; ZERO CHECKSUM;*********************************       LDA #$00       STA CHKSUM       STA CHKSUM+1;*********************************; BUILD FIRST RECORD;*********************************       LDY #$00       LDA #';'       STA RECBUF,Y       INY;*********************************; SKIP NUMBER OF BYTES FIELD;*********************************       INY        ;INCREMENT PAST FIRST DIGIT       INY        ;INCREMENT PAST SECOND DIGIT       STY RECPNT ;STORE RECORD POSITION;*********************************; PUT START ADDRESS IN RECORD BUFFER; HIGH BYTE FIRST AND THEN LOW BYTE; HIGH BYTE IN ADDHI; LOW  BYTE IN ADDLO; RETURNS CHARACTERS IN ADDCHR;*********************************       LDA RECLO   ;RECORD ADDRESS LOW BYTE       STA ADDLO       JSR SUMBYT  ;SUM BYTES FOR CHECKSUM       LDA RECHI   ;RECORD ADDRESS HIGH BYTE       STA ADDHI       JSR SUMBYT  ;SUM BYTES FOR CHECKSUM       JSR CVTADD  ;CONVERT TO PETASCII;*********************************; TRANSFER CHARS FROM ADDCHR TO; THEIR POSTIONS IN RECBUF;*********************************       LDX #$00       LDY RECPNT;N1     LDA ADDCHR,X       STA RECBUF,Y       INY       INX       CPX #$04       BNE N1       STY RECPNT;*********************************; LOOP;*********************************       LDA #$00       STA DATCNTRLOOP  NOP       LDX #$08    ;FILE #8       JSR CHKIN   ;INPUT FILE;*********************************; READ IN BYTE DATA;*********************************; PUT DATA BYTE IN RECORD BUFFER; RETURNS CHARACTERS IN BYTCHR;*********************************       JSR CHRIN   ;DATA BYTE       STA CURBYT  ;STASH DATA BYTE       JSR SUMBYT  ;SUM BYTES FOR CHECKSUM;*********************************; CONVERT DATA BYTE AND LOAD INTO RECORD;*********************************       LDA CURBYT  ;RECOVER DATA BYTE       JSR CVTBYT  ;DATA IN PETASCII       LDY RECPNT       LDA BYTCHR       STA RECBUF,Y       INY       LDA BYTCHR+1       STA RECBUF,Y       INY       STY RECPNT;*********************************; CHECK FOR DISK ERROR - LIKE END OF FILE;*********************************      JSR READST   ;READ STATUS      BEQ CUROK    ;NEXT BYTE      JMP ENDFIL;*********************************; INCREMENT RECORD COUNT;*********************************CUROK = *       LDX DATCNT       INX       STX DATCNT;*********************************; CHECK FOR MAXIMUM $18 BYTES;*********************************       CPX #$18       BNE RLOOP;*********************************; GO BACK AND SET RECORD DATA COUNT;*********************************       LDA DATCNT       JSR SUMBYT  ;SUM BYTES FOR CHECKSUM       LDA DATCNT       JSR CVTBYT  ;DATA IN PETASCII       LDA BYTCHR       LDY #$01       STA RECBUF,Y       INY       LDA BYTCHR+1       STA RECBUF,Y;*********************************; INCREMENT PROGRAM ADDRESS BY BYTE COUNT; TO LOAD INTO NEXT RECORD;*********************************       CLC         ;CLEAR CARRY       LDA RECLO   ;GET RECORD ADDRESS LO BYTE       ADC DATCNT  ;ADD TO DATA BYTE COUNT       STA RECLO   ;SAVE NEW RECORD ADDRESS       LDA #$00    ;NEVER MORE TAN 255 BYTES TO A RECORD       ADC RECHI   ;ADD WITH CARRY TO RECORD ADDRESS       STA RECHI   ;STORE RECORD ADDRESS;*********************************; LOAD DATA CHECKSUM INTO RECORD; (FOR NOW DUMMY);*********************************; CONVERT CHECKSUM TO FOUR PETASCII CHARS; HIGH BYTE FIRST AND THEN LOW BYTE; HIGH BYTE IN ADDHI; LOW  BYTE IN ADDLO; RETURNS CHARACTERS IN ADDCHR;*********************************       LDA CHKSUM       STA ADDLO       LDA CHKSUM+1       STA ADDHI       JSR CVTADD  ;CONVERT TO PETASCII;*********************************; TRANSFER CHARCTERS TO RECORD BUFFER;*********************************              LDY RECPNT       LDA ADDCHR       STA RECBUF,Y       INY       LDA ADDCHR+1       STA RECBUF,Y       INY       LDA ADDCHR+2       STA RECBUF,Y       INY       LDA ADDCHR+3       STA RECBUF,Y       INY;*********************************; TERMINATING CR;*********************************       LDA #$0D       STA RECBUF,Y       INY;*********************************; TERMINATE RECORD WITH A NULL;*********************************       LDA #$00       STA RECBUF,Y;*********************************; WRITE RECORD TO INTERFACE FILE;*********************************       LDX #$07      ;FILE #Y       JSR CHKOUT    ;SET TO OUTPUT;*********************************; WRITE RECORD TO INTERFACE FILE;*********************************       LDY #$00WD1    STY RECPNT       LDA RECBUF,Y       BEQ WDONE       JSR CHROUT       LDY RECPNT       INY       BNE WD1       BEQ WD1;*********************************; RESET OUTPUT TO SCREEN;*********************************WDONE = *       LDX #$03      ;FILE #Y       JSR CHKOUT    ;SET TO OUTPUT;*********************************; CHECK SCREEN OUTPUT OPTIONS;*********************************       LDA SCROPT       BNE SDONE;*********************************; PRINT RECROED TO SCREEN;*********************************       LDY #$00WD4    STY RECPNT       LDA RECBUF,Y       BEQ SDONE       JSR CHROUT       LDY RECPNT       INY       BNE WD4       BEQ WD4;*********************************; GOT BACK AND CREATE ANOTHER RECORD;*********************************SDONE =*      JMP CLOOP;*********************************; END OF PROGRAM FILE; CLOSE OUT LAST DATA RECORD; AND GENERATE END RECORD; (FOR NOW NOTHTING);*********************************ENDFIL =*;       LDY RECPNT;       INY;       STY RECPNT;*********************************; INCREMENT RECORD DATA COUNT;*********************************       LDX DATCNT       INX       STX DATCNT       LDA DATCNT       JSR SUMBYT  ;SUM BYTES FOR CHECKSUM       LDA DATCNT       JSR CVTBYT ;DATA IN PETASCII;*********************************; LOAD DATA BYTE COUNT IN LAST RECORD;*********************************       LDA BYTCHR       LDY #$01       STA RECBUF,Y       INY       LDA BYTCHR+1       STA RECBUF,Y;*********************************; LOAD DATA CHECKSUM INTO RECORD;*********************************; CONVERT CHECKSUM TO FOUR PETASCII CHARS; HIGH BYTE FIRST AND THEN LOW BYTE; HIGH BYTE IN ADDHI; LOW  BYTE IN ADDLO; RETURNS CHARACTERS IN ADDCHR;*********************************       LDA CHKSUM       STA ADDLO       LDA CHKSUM+1       STA ADDHI       JSR CVTADD  ;CONVERT TO PETASCII;*********************************; TRANSFER CHARCTERS TO RECORD BUFFER;*********************************              LDY RECPNT       LDA ADDCHR       STA RECBUF,Y       INY       LDA ADDCHR+1       STA RECBUF,Y       INY       LDA ADDCHR+2       STA RECBUF,Y       INY       LDA ADDCHR+3       STA RECBUF,Y       INY;*********************************; TERMINATING CR;*********************************       LDA #$0D       STA RECBUF,Y       INY;*********************************; TERMINATE RECORD WITH A NULL;*********************************       LDA #$00       STA RECBUF,Y;*********************************; WRITE RECORD TO INTERFACE FILE;*********************************       LDX #$07      ;FILE #Y       JSR CHKOUT    ;SET TO OUTPUT;*********************************; WRITE RECORD TO INTERFACE FILE;*********************************       LDY #$00WD2    STY RECPNT       LDA RECBUF,Y       BEQ PDONE       JSR CHROUT       LDY RECPNT       INY       BNE WD2       BEQ WD2;*********************************; RESET OUTPUT TO SCREEN;*********************************PDONE =*       LDX #$03      ;FILE #3       JSR CHKOUT    ;SET TO OUTPUT;*********************************; CHECK SCREEN OUTPUT OPTIONS;*********************************       LDA SCROPT       BNE RDONE;*********************************; PRINT RECORD TO SCREEN;*********************************       LDY #$00WD6    STY RECPNT       LDA RECBUF,Y       BEQ RDONE       JSR CHROUT       LDY RECPNT       INY       BNE WD6       BEQ WD6;*********************************; PRINT ; TO THE SCREEN;*********************************RDONE =*       LDA SCROPT       BEQ SSEMI2       LDA #$';'       JSR CHROUT;*********************************; ZERO CHECKSUM;*********************************SSEMI2 =*       LDA #$00       STA CHKSUM       STA CHKSUM+1;*********************************; RECORD STARTING CHARACTER;*********************************       LDY #$00       STY RECPNT ;STORE RECORD POSITION       LDA #';'       STA RECBUF,Y       INY       STY RECPNT ;STORE RECORD POSITION;*********************************; ZERO BYTES OF DATA;*********************************       LDY RECPNT ;GET RECORD POSITION       LDA #'0'       STA RECBUF,Y       INY       STA RECBUF,Y       INY       STY RECPNT;*********************************; CHECKSUM FOR ZERO BYTE COUNT;*********************************       LDA #$00       JSR SUMBYT  ;SUM BYTES FOR CHECKSUM;*********************************; TOTAL NUMBER OF RECORDS ; NOT INCLUDING THIS LAST RECORD;*********************************       LDA RECCNT       STA ADDLO       JSR SUMBYT  ;SUM BYTES FOR CHECKSUM       LDA RECCNT+1       STA ADDHI       JSR SUMBYT  ;SUM BYTES FOR CHECKSUM       JSR CVTADD  ;CONVERT TO PETASCII;*********************************; TRANSFER CHARCTERS TO RECORD BUFFER;*********************************              LDY RECPNT       LDA ADDCHR       STA RECBUF,Y       INY       LDA ADDCHR+1       STA RECBUF,Y       INY       LDA ADDCHR+2       STA RECBUF,Y       INY       LDA ADDCHR+3       STA RECBUF,Y       INY       STY RECPNT;*********************************; LOAD DATA CHECKSUM INTO RECORD;*********************************; CONVERT CHECKSUM TO FOUR PETASCII CHARS; HIGH BYTE FIRST AND THEN LOW BYTE; HIGH BYTE IN ADDHI; LOW  BYTE IN ADDLO; RETURNS CHARACTERS IN ADDCHR;*********************************       LDA CHKSUM       STA ADDLO       LDA CHKSUM+1       STA ADDHI       JSR CVTADD  ;CONVERT TO PETASCII;*********************************; TRANSFER CHARCTERS TO RECORD BUFFER;*********************************              LDY RECPNT       LDA ADDCHR       STA RECBUF,Y       INY       LDA ADDCHR+1       STA RECBUF,Y       INY       LDA ADDCHR+2       STA RECBUF,Y       INY       LDA ADDCHR+3       STA RECBUF,Y       INY;*********************************; TERMINATING CR;*********************************       LDA #$0D       STA RECBUF,Y       INY;*********************************; TERMINATE RECORD WITH A NULL;*********************************       LDA #$00       STA RECBUF,Y;*********************************; WRITE RECORD TO INTERFACE FILE;*********************************       LDX #$07      ;FILE #Y       JSR CHKOUT    ;SET TO OUTPUT       LDY #$00WD3    STY RECPNT       LDA RECBUF,Y       BEQ EDONE       JSR CHROUT       LDY RECPNT       INY       BNE WD3       BEQ WD3;*********************************; CHECK SCREEN OUTPUT OPTIONS;*********************************EDONE =*       LDX #$03      ;FILE #Y       JSR CHKOUT    ;SET TO OUTPUT;       LDA SCROPT       BNE LDONE       LDY #$00WD5    STY RECPNT       LDA RECBUF,Y       BEQ LDONE       JSR CHROUT       LDY RECPNT       INY       BNE WD5       BEQ WD5;*********************************;;*********************************LDONE =*       JMP QUITER    ;NEXT RECORD;*********************************; SUM BYTES FOR CHECKSUMS;*********************************SUMBYT CLC            ;CLEAR CARRY       ADC CHKSUM     ;ADD BYTE OF CHECK       STA CHKSUM     ;REPLACE BYTE       BCC S1         ;IF NO CARRY OK       INC CHKSUM+1   ;INC HIGH BYTES1     RTS            ;RETURN;*********************************; END OF RECORDS - CLOSE OUT;*********************************QUITER =*;*********************************; CLOSE OUT FILE AND RESET I/O;*********************************       LDX #$03      ;FILE #Y       JSR CHKOUT    ;SET TO OUTPUT       LDX #MSG15-MSG1 ;OFFSET END OF FILE       JSR PRINT       ;PRINT HEADING       LDA #$03        ;FILE #7       JSR CLOSE       ;CLOSE       LDA #$07        ;FILE #7       JSR CLOSE       ;CLOSE       LDA #$08        ;FILE #7       JSR CLOSE       ;CLOSE       JSR CLRCHN      ;RESET I/O        RTS             ;BACK TO BASIC;*********************************; CONVERT WORD ADDRESS INTO 4 PETASCII CHAR;*********************************ADDCHP .BYTE $AAADDCHR .BYTE $AA,$AA,$AA,$AA,$00;*********************************CVTADD =* LDA #$00 STA ADDCHP LDA ADDLO    ;LOW ADDRESS PHA          ;STACK IT LDA ADDHI ;GET HIGH BYTE JSR RIGHT    ;PRINT IT PLA          ;PULL LOW BYTE;RIGHT PHA     ;STACK BYTE LSR A        ;RIGHT JUSTIFY LSR A        ; BYTE IN LOW LSR A        ;  NIBBLE LSR A        ; JSR CHGASC   ;CONVERT BYTE TAX          ;STORE IN X PLA          ;PULL BYTE AND #$0F     ;MASK HIGH JSR CHGASC   ;CONVERT BYTE;*********************************; STORE 2 PETASCII CHARS OF ADDRESS NIBBLE;********************************* PHA          ;STACK RESULT TXA          ;GET HIGH NIBBLE  LDX ADDCHP STA ADDCHR,X INX PLA          ;GET LOW NIBBLE STA ADDCHR,X INX STX ADDCHP RTS;*********************************; CONVERT WORD ADDRESS INTO 4 PETASCII CHAR;*********************************BYTCHR .BYTE $AA,$AA,$00;*********************************CVTBYT PHA     ;STACK BYTE LSR A        ;RIGHT JUSTIFY LSR A        ; BYTE IN LOW LSR A        ;  NIBBLE LSR A        ; JSR CHGASC   ;CONVERT BYTE TAX          ;STORE IN X PLA          ;PULL BYTE AND #$0F     ;MASK HIGH JSR CHGASC   ;CONVERT BYTE;*********************************; STORE 2 PETASCII CHARS OF ADDRESS NIBBLE;********************************* PHA          ;STACK RESULT TXA          ;GET HIGH NIBBLE  STA BYTCHR INX PLA          ;GET LOW NIBBLE STA BYTCHR+1 RTS;*********************************; CONVERT BYTE TO ASCII CHAR;*********************************CHGASC CLC         ;CLEAR CARRY       ADC #$F6    ;ADD OFFSET       BCC NOSIX   ;IF C=0 OK       ADC #$06    ;ADD OFFSSETNOSIX  ADC #$3A    ;ADD OFFSET       RTS         ;RETURN;*********************************;  DISK ERROR CHECK;*********************************DISERR LDA #$08    ;DEV #8       STA $BA     ;PUT IN DEV TABLE       JSR $FFB4   ;SEND TALK       LDA #$6F    ;SECONDARY ADDRESS       STA $B9     ;PUT IN TABLE       JSR $FF96   ;SEND SEC       JSR $FFA5   ;GET FIRST BYTE       CMP #$30    ;IS IT A ZERO       BNE DLOOC   ;IF NOT ZERO ERRORDLOOE  JSR $FFA5   ;GET BYTE       CMP #$0D    ;IS IT CR?       BNE DLOOE   ;GET NEXT BYTE       JSR $FFAB   ;UNTALK       CLC         ;NO ERROR FLAG       RTS         ;RETURN;*********************************; PRINT DISK ERROR;*********************************DLOOC  PHA         ;STACK BYTE       LDA #$0D    ;ASCII CR       JSR CHROUT  ;PRINT IT       PLA         ;GET BYTE       JSR CHROUT  ;PRINT ITDLOOA  JSR $FFA5   ;GET NEXT BYTE       JSR CHROUT  ;PRINT IT       CMP #$0D    ;IS IT CR       BNE DLOOA   ;GET NEXT BYTE       JSR $FFAB   ;UNTALK       SEC         ;SET ERROR FLAG       RTS         ;RETURN;*********************************; STORAGE;*********************************USER   .WORD $AAAA ;CHECKSUM VALUEOFFSET .WORD $AAAA ;LOAD OFFSETNUMBYT .BYTE $AA   ;NUMBER BYTESCURBYT .BYTE $AA   ;CURRENT BYTE IN RECORDRECORD .WORD $AAAA ;RECORD NUMBERSTADD  .BYTE $AA   ;START ADDRESSCOUNT  .BYTE $AA   ;COUNTERTEMP   .BYTE $AA   ;TEMPOARYSCROPT .BYTE $AA   ;SCREEN OUPUT OPTION;*********************************COUNT1 .BYTE $AA    ;COUNTER;*********************************; ERROR MESSAGES;*********************************MSG1 .BYTE $0D.BYTE 'BAD RECORD COUN',$D4MSG2 .BYTE $0D.BYTE 'BREAK',$8DMSG3 .BYTE $0D.BYTE 'END OF LOA',$C4MSG4 .BYTE $0D.BYTE 'BAD RECORD',$8DMSG5 .BYTE $0D.BYTE 'CHECKSUM ERRO',$D2MSG6 .BYTE $0D.BYTE 'FILE ERRO',$D2;*********************************; MESSAGES; ; FIRST TWO CHARACTERS IN TITLE; ARE DEFINED IN MAIN DEFINITION; SOURCE CODE FILE; LOLOADER.ASM OR HILOADER.ASM;;*********************************MSG7 .BYTE $0D,$0D,$0D.BYTE 'PRG2OBJ.C64 V072882'.BYTE $0D.BYTE '(C) 1982 BY COMMODORE BUSINESS '.BYTE 'MACHINES'.BYTE $A0MSG8 .BYTE $0D.BYTE 'OBJECT FILE NAME ?',$A0MSG9 .BYTE $0D.BYTE 'PRG NAME',$BAMSG10 .BYTE $0D.BYTE 'OBJ NOT SAVED',$A0MSG11 .BYTE $0D.BYTE 'ADDRESS',$A0MSG12 .BYTE $0D.BYTE 'COUNT',$A0MSG13 .BYTE $0D.BYTE 'BYTE DATA',$8DMSG14 .BYTE $0D.BYTE 'CHECKSUM',$A0MSG15 .BYTE $0D.BYTE 'END OF FILE',$8DMSG16 .BYTE $0D.BYTE 'LAST RECORD',$8D;*********************************; START LOAD ADDRESS;*********************************SAV   .WORD $AAAA  ;ADDRESS SAVESA    .WORD $AAAA  ;START ADDRESSEA    .WORD $AAAA  ;END ADDRESSSAFG  .BYTE $00    ;START ADDRESS FLAG;*********************************; HEX DIGITS;*********************************DIGIT1 .BYTE $AADIGIT2 .BYTE $AADIGIT3 .BYTE $AADIGIT4 .BYTE $AA;*********************************; FILENAME NAME BUFFER;*********************************OUF .BYTE $AA,$AA,$AA,$AA,$AA,$AA.BYTE $AA,$AA,$AA,$AA,$AA,$AA.BYTE $AA,$AA,$AA,$AA,$AA,$AA;*********************************; FILENAME NAME BUFFER;*********************************PUF .BYTE $AA,$AA,$AA,$AA,$AA,$AA.BYTE $AA,$AA,$AA,$AA,$AA,$AA.BYTE $AA,$AA,$AA,$AA,$AA,$AA;*********************************; INIT DISK;*********************************INIT  .BYTE 'I0';*********************************OBJM  .BYTE ',S,W';*********************************PROGM .BYTE ',P,R';*********************************SAVO .BYTE $AASAVP .BYTE $AA;*********************************RECHI  .BYTE $AARECLO  .BYTE $AA;*********************************ADDHI  .BYTE $AAADDLO  .BYTE $AA;*********************************CURDAT .BYTE $AA;*********************************CHKSUM .WORD $AAAA;*********************************; SYMBOLIC DISASSEMBLY OPTION;*********************************MSS1 .BYTE $0D .BYTE 'OUTPUT TO SCREEN (Y OR N/CR)? ' .BYTE 0;*********************************; OUTPUT STRING ROUTINE;*********************************PRINT  STX COUNT   ;PUT X IN COUNTPLOOP  LDX COUNT   ;LOAD X FROM COUNT       LDA MSG1,X  ;LOAD CHAR       PHP         ;SAVE STATUS FLAG       AND #$7F    ;MASK BIT 8       JSR CHROUT  ;PRINT CHAR       INC COUNT   ;INC OFFSET       PLP         ;GET STATUS FLAG       BPL PLOOP   ;IF BIT 8 ZERO       RTS         ;RETURN;*********************************; OUTPUT UTILITIES;*********************************; STRING OUTPUT ROUTINE;*********************************STRPNT STA ZEROUR     ;POINTER TO       STY ZEROUR+1   ;MESSAGE       LDY #$00       ;OFFSETSOUT   LDA (ZEROUR),Y ;GET CHAR       BEQ SEXIT      ;IF ZERO EXIT       JSR CHROUT     ;PRINT       INY            ;INC OFFSET       BNE SOUT       ;LOOPSEXIT  RTS            ;RETURN;*********************************; INPUT UTILITIES;*********************************; GET OPTION (CR/Y OR N): Y=C=0;*********************************CRYS JSR CHRIN CMP #'Y' BEQ CRYS1 CMP #$0D BEQ CRYS1 BNE CRNO1;*********************************; GET OPTION (Y OR CR/N): Y=C=0;*********************************CRNO JSR CHRIN CMP #'N' BEQ CRNO1 CMP #$0D BEQ CRNO1CRYS1 CLC RTSCRNO1 SEC RTS;*********************************; INPUT STRING ROUTINE;*********************************INSTNO LDY #$00INSTN1 JSR CHRIN       STA OUF,Y       INY       CMP #$0D       BNE INSTN1       DEY       RTS;*********************************; INPUT STRING ROUTINE;*********************************INSTNP LDY #$00INSTN2 JSR CHRIN       STA PUF,Y       INY       CMP #$0D       BNE INSTN2       DEY       RTS;*********************************;;*********************************;.LIB FILERR.ASM;*********************************DATCNT .BYTE $AARECCNT .WORD $AAAARECPNT .BYTE $AARECBUF =*       .BYTE $AA,$AA,$AA,$AA,$AA,$AA       .BYTE $AA,$AA,$AA,$AA,$AA,$AA       .BYTE $AA,$AA,$AA,$AA,$AA,$AA       .BYTE $AA,$AA,$AA,$AA,$AA,$AA       .BYTE $AA,$AA,$AA,$AA,$AA,$AA       .BYTE $AA,$AA,$AA,$AA,$AA,$AA       .BYTE $AA,$AA,$AA,$AA,$AA,$AA       .BYTE $AA,$AA,$AA,$AA,$AA,$AA       .BYTE $AA,$AA,$AA,$AA,$AA,$AA       .BYTE $AA,$AA,$AA,$AA,$AA,$AA       .BYTE $AA,$AA,$AA,$AA,$AA,$AA       .BYTE $AA,$AA,$AA,$AA,$AA,$AA       .BYTE $AA,$AA,$AA,$AA,$AA,$AA       .BYTE $AA,$AA,$AA,$AA,$AA,$AA       .BYTE $AA,$AA,$AA,$AA,$AA,$AA       .BYTE $AA,$AA,$AA,$AA,$AA,$AA;*********************************;.END